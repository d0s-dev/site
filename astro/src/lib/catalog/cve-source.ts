/**
 * CVE Database types and lazy-loading utilities for d0s.dev site
 */

import type { CatalogSource } from "./types";

const APPS_BASE_URL = "https://raw.githubusercontent.com/d0s-dev/apps";
const DEFAULT_BRANCH = process.env.CATALOG_SOURCE_BRANCH ?? "main";
const DEFAULT_REF = DEFAULT_BRANCH.startsWith("refs/")
  ? DEFAULT_BRANCH
  : `refs/heads/${DEFAULT_BRANCH}`;

const CVES_PATH = `${APPS_BASE_URL}/${DEFAULT_REF}/catalog/cves.json`;

/** A single CVE entry from the central database */
export interface CVEEntry {
  id: string;
  severity: string;
  cvssScore?: number;
  description?: string;
  urls?: string[];
  package?: string;
  version?: string;
  fixedIn?: string;
  affectedApps?: AffectedApp[];
  firstSeen?: string;
  lastSeen?: string;
}

/** An app affected by a CVE */
export interface AffectedApp {
  app: string;
  provider: string;
  version: string;
  image: string;
  arch: string;
  package?: string;
}

/** The central CVE database structure */
export interface CVEDatabase {
  version: string;
  lastUpdated: string;
  cves: Record<string, CVEEntry>;
  stats: {
    totalUnique: number;
    bySeverity: Record<string, number>;
  };
}

export interface CVEDatabaseResult {
  source: CatalogSource;
  fetchedAt: number;
  database: CVEDatabase | null;
  error?: string;
}

// Cache for the CVE database
let cveDbCache: {
  database: CVEDatabase | null;
  fetchedAt: number;
  etag?: string;
} | null = null;

const CVE_CACHE_TTL = 10 * 60 * 1000; // 10 minutes

/**
 * Fetch the central CVE database (lazy-loaded on first request)
 */
export async function fetchCVEDatabase(): Promise<CVEDatabaseResult> {
  const now = Date.now();

  // Check cache freshness
  if (cveDbCache && now - cveDbCache.fetchedAt < CVE_CACHE_TTL) {
    return {
      source: "cache",
      fetchedAt: cveDbCache.fetchedAt,
      database: cveDbCache.database,
    };
  }

  try {
    const headers: HeadersInit = {};
    if (cveDbCache?.etag) {
      headers["If-None-Match"] = cveDbCache.etag;
    }

    const response = await fetch(CVES_PATH, { headers });

    if (response.status === 304 && cveDbCache?.database) {
      // Not modified, update timestamp
      cveDbCache.fetchedAt = now;
      return {
        source: "cache",
        fetchedAt: now,
        database: cveDbCache.database,
      };
    }

    if (!response.ok) {
      throw new Error(`Failed to fetch CVE database: ${response.status}`);
    }

    const database = (await response.json()) as CVEDatabase;
    const etag = response.headers.get("etag") ?? undefined;

    cveDbCache = {
      database,
      fetchedAt: now,
      etag,
    };

    return {
      source: "remote",
      fetchedAt: now,
      database,
    };
  } catch (error) {
    // Return cached data if available
    if (cveDbCache?.database) {
      return {
        source: "cache",
        fetchedAt: cveDbCache.fetchedAt,
        database: cveDbCache.database,
        error: String(error),
      };
    }

    return {
      source: "remote",
      fetchedAt: now,
      database: null,
      error: String(error),
    };
  }
}

/**
 * Get a single CVE entry by ID (lazy-loads database if needed)
 */
export async function getCVEById(cveId: string): Promise<CVEEntry | null> {
  const result = await fetchCVEDatabase();
  if (!result.database) return null;
  return result.database.cves[cveId] ?? null;
}

/**
 * Get multiple CVE entries by IDs
 */
export async function getCVEsByIds(
  cveIds: string[],
): Promise<Record<string, CVEEntry>> {
  const result = await fetchCVEDatabase();
  if (!result.database) return {};

  const entries: Record<string, CVEEntry> = {};
  for (const id of cveIds) {
    const entry = result.database.cves[id];
    if (entry) entries[id] = entry;
  }
  return entries;
}

/**
 * Get CVEs affecting a specific app/version combination (V2 schema)
 * Provider is no longer a separate key in V2 manifests
 */
export async function getCVEsForVersion(
  appId: string,
  version: string,
): Promise<CVEEntry[]> {
  const result = await fetchCVEDatabase();
  if (!result.database) return [];

  const cves: CVEEntry[] = [];
  for (const entry of Object.values(result.database.cves)) {
    const matches = entry.affectedApps?.some(
      (a) => a.app === appId && a.version === version,
    );
    if (matches) {
      cves.push(entry);
    }
  }

  // Sort by severity (critical first) then by CVSS score
  const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
  return cves.sort((a, b) => {
    const aSev = severityOrder[a.severity as keyof typeof severityOrder] ?? 4;
    const bSev = severityOrder[b.severity as keyof typeof severityOrder] ?? 4;
    if (aSev !== bSev) return aSev - bSev;
    return (b.cvssScore ?? 0) - (a.cvssScore ?? 0);
  });
}

/**
 * Get CVEs affecting a specific app/version/provider combination
 * @deprecated Use getCVEsForVersion for V2 schema
 */
export async function getCVEsForImage(
  appId: string,
  provider: string,
  version: string,
  imageName?: string,
): Promise<CVEEntry[]> {
  const result = await fetchCVEDatabase();
  if (!result.database) return [];

  const cves: CVEEntry[] = [];
  for (const entry of Object.values(result.database.cves)) {
    const matches = entry.affectedApps?.some(
      (a) =>
        a.app === appId &&
        a.provider === provider &&
        a.version === version &&
        (imageName ? a.image === imageName : true),
    );
    if (matches) {
      cves.push(entry);
    }
  }

  // Sort by severity (critical first) then by CVSS score
  const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
  return cves.sort((a, b) => {
    const aSev = severityOrder[a.severity as keyof typeof severityOrder] ?? 4;
    const bSev = severityOrder[b.severity as keyof typeof severityOrder] ?? 4;
    if (aSev !== bSev) return aSev - bSev;
    return (b.cvssScore ?? 0) - (a.cvssScore ?? 0);
  });
}

/**
 * Generate NVD link for a CVE
 */
export function getNVDLink(cveId: string): string {
  return `https://nvd.nist.gov/vuln/detail/${cveId}`;
}

/**
 * Generate MITRE link for a CVE
 */
export function getMITRELink(cveId: string): string {
  return `https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId}`;
}
